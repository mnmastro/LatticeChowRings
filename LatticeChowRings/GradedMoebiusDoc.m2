document {
	Key => {idealGradedMoebiusAlgebra, 
	    (idealGradedMoebiusAlgebra, Matroid),
	    (idealGradedMoebiusAlgebra, Graph)
	    },
	
	Headline => "the defining ideal of the graded Moebius algebra of a matroid",
	
	Usage => "idealGradedMoebiusAlgebra M \n idealGradedMoebiusAlgebra G",
	
	Inputs => {
	    	"M" => Matroid,
	    	"G" => Graph,
		},
	
	Outputs => {
		Ideal => {"the defining ideal of the graded Moebius algebra of the matroid/graph"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"The graded Moebius algebra of a matroid M is the finite-dimensional algebra having
	    basis elements y_F in one-to-one correspondence with the flats F of M with multiplication
	    given by declaring y_F*y_G = y_H (where H is the join of F and G) if rk H = rk F + rk G, and
	    by setting y_F*y_G = 0 otherwise.  This function computes the defining ideal of a minimal
	    presentation for the graded Moebius algebra of the matroid M.  The generators of the ideal
	    include the squares of all the variables and certain binomials corresponding to circuits 
	    of the matroid.  By definition, the value of the  Hilbert function of the graded Moebius 
	    algebra in degree r records the number of flats of M of rank r."},   
	
	EXAMPLE {
		"M = uniformMatroid(4, 5);",
		"I = idealGradedMoebiusAlgebra M",
		"numerator hilbertSeries(I, Reduce => true)"
		},
	    
	PARA {"Given a graph G, the command idealGradedMoebiusAlgebra G can be used to compute
	    the definig ideal of the graded Moebius algebra of its cycle matroid."},    
	
	EXAMPLE {
	    	"G = completeGraph 4",
		"idealGradedMoebiusAlgebra G",
		},
	    
	PARA {"The graded Moebius algebra of a matroid M can also be identified as a special subalgebra of
	    the augmented Chow ring of M.  In the standard presentation of the augmented Chow ring of M with
	    augmented variables y_i, the graded Moebius algebra is the subalgebra generated by the y_i."},
	    
	SeeAlso => {idealAugmentedChowRing}
	    }

document {
	Key => {isCChordal, (isCChordal, Matroid)},
	
	Headline => "whether a matroid is C-chordal",
	
	Usage => "isCChordal M",
	
	Inputs => {
	    	"M" => Matroid,
		},
	
	Outputs => {
		Boolean => {"whether the matroid is C-chordal"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"A matroid M is C-chordal if for every circuit C of size at least 4 in M there are circuits
	    A and B whose intersection consists of a single element and whose symmetric difference is C."},
	    
	PARA {"For the cycle matroid of a graph G, the matroid being C-chordal is equivalent to the graph 
	    being chordal."},    
	
	EXAMPLE {
	    	"isCChordal matroid completeGraph 5",
		},
	    
	PARA {"The following checks whether two non-graphic matroids are C-chordal."},    
	
	EXAMPLE {
	    	"isCChordal specificMatroid \"fano\"",
		"isCChordal dual matroid completeGraph 5",
		},
	    
	 SeeAlso => {}
	    }


document {
	Key => {isSimpleVertex, (isSimpleVertex, Graph, Thing)},
	
	Headline => "whether a vertex of a graph is a simple vertex",
	
	Usage => "isSimpleVertex(G, v)",
	
	Inputs => {
	    	"G" => Graph,
	    	"v" => Thing => {"a vertex of the graph"},
		},
	
	Outputs => {
		Boolean => {"whether the vertex is a simple vertex"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"The closed neighborhood of a vertex v in a graph G is the set of all neighbors
	    of v together with v.  The vertex v is simple if the distinct sets of closed 
	    neighborhoods of vertices in the closed neighborhood of v are totally ordered by
	    inclusion."},
	    
	PARA {"Every vertex of a complete graph is simple."},    
	
	EXAMPLE {
	    	"G = completeGraph 5",
		"all(vertexSet G, v -> isSimpleVertex(G, v) )",
		},
	    
	PARA {"On the other hand, no vertex of a sun graph is simple."},    
	
	EXAMPLE {
	    	"G = sunGraph 4",
		"any(vertexSet G, v -> isSimpleVertex(G, v) )",
		},
	    
	SeeAlso => {isStronglyChordal}
	    }

document {
	Key => {isStrongElimOrder, (isStrongElimOrder, Graph, List)},
	
	Headline => "whether a list of vertices is a strong elimination order",
	
	Usage => "isStrongElimOrder(G, V)",
	
	Inputs => {
	    	"G" => Graph,
		"V" => List => {"a permuted list of the vertices of the graph"}
		},
	
	Outputs => {
		Boolean => {"whether the given ordering of vertices is a strong elimination
		    order"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"An ordering v_1,...,v_n of the vertices of a graph G is a strong elimination order if
	    for each i and for any neighbors v_k and v_l of v_i in the induced subgraph G_i = G[v_i,...,v_n]
	    with k < l, the closed neighbordhood of v_k in G_i is contained in the closed neighborhood
	    of v_l in G_i.  This function checks whether a given ordering of the vertices of a graph
	    is a strong elimination order.  Graphs having a strong elimination order are called strongly
	    chordal."},
	
	EXAMPLE {
	    	"B = deleteVertex(sunGraph 4, 7)",
		"isStronglyChordal B",
		"isStrongElimOrder(B, {0, 1, 2, 3, 4, 5, 6})",
		"isStrongElimOrder(B, {4, 6, 5, 0, 3, 1, 2})",
		},
	    
	 SeeAlso => {isStronglyChordal, strongElimOrder}
	    }
	
document {
	Key => {isStronglyChordal, (isStronglyChordal, Graph)},
	
	Headline => "whether a graph is strongly chordal",
	
	Usage => "isStronglyChordal G",
	
	Inputs => {
	    	"G" => Graph,
		},
	
	Outputs => {
		Boolean => {"whether the graph is strongly chordal"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"A graph G is strongly chordal if it is chordal and every cycle C of even
	    length in G has a chord whose ends are an odd distance apart in C.  Equivalently,
	    G is strongly chordal if and only if it is chordal and every induced subgraph of
	    G has a simple vertex. As a result, there is always a (not necessarily unique) 
	    ordering v_1,...,v_n of the vertices of a strongly chordal graph in which 
	    v_i is a simple vertex for the subgraph induced by v_1,...,v_{i-1} for each i.
	    In practice, this function decides whether a graph is strongly chordal by 
	    determining whether it is possible to construct such an ordering."},   
	
	EXAMPLE {
		"G = graph {{a, b}, {a, c}, {b, c}, {b, d}, {b, e}, {c, d}, {c, e}, {d, e}}",
		"isStronglyChordal G",
		},
	    
	PARA {"Yet another characterization of strongly chordal graphs is that they are 
	    precisely the chordal graphs that do not contain a sun graph as an induced
	    subgraph."},    
	
	EXAMPLE {
	    	"G = sunGraph 4",
		"isChordal G",
		"isStronglyChordal G",
		},
	    
	SeeAlso => {isSimpleVertex}
	    }

document {
	Key => {isStronglyTChordal, (isStronglyTChordal, Matroid, List)},
	
	Headline => "whether a matroid is strongly T-chordal for a given ordering of its ground set",
	
	Usage => "isStronglyTChordal(M, E)",
	
	Inputs => {
	    	"M" => Matroid,
		"E" => List => {"a permuted list of elements of the ground set of the matroid"}
		},
	
	Outputs => {
		Boolean => {"whether the matroid is strongly T-chordal for the given ordering of its ground set"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"A strong elimination order for a matroid M is an ordering of the elements of its ground set
	    such that for each circuit C of size at least 4 in M and each i in C different from the largest
	    element of C in the given ordering, there is a 3-circuit T such that T - C has size 1 and the
	    largest element of T in the given ordering is contained in C.  If a matroid has a strong elimination
	    order, it is called strongly T-chordal.  This function checks whether a given ordering of the 
	    ground set of a matroid is a strong elimination order."}, 
	
	EXAMPLE {
	    	"B = deleteVertex(sunGraph 4, 7)",
		"M = matroid B",
		"hashTable apply(#(M.groundSet), i -> i => M.cache.groundSet#i)",
		"isStronglyTChordal(M, {3, 6, 7, 9, 10, 11, 2, 1, 5, 0, 4, 8})",
		},
	    
	 SeeAlso => {isCChordal}
	    }

document {
	Key => {strongElimOrder, (strongElimOrder, Graph)},
	
	Headline => "find a strong elimination order of a strongly chordal graph",
	
	Usage => "strongElimOrder G",
	
	Inputs => {
	    	"G" => Graph,
		},
	
	Outputs => {
		List => {"an ordering of vertices that is a strong elimination order"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"This produces an ordering of the vertices of a strongly chordal graph that
	    is a strong elimination order. See ", TO isStrongElimOrder, " and ", TO isStronglyChordal,
	    " for more information about strong elimination orders and strongly chordal graphs."},
	
	EXAMPLE {
	    	"B = deleteVertex(sunGraph 4, 7)",
		"V = strongElimOrder B",
		"isStrongElimOrder(B, V)",
		},
	    
	 SeeAlso => {isStrongElimOrder, isStronglyChordal}
	    }

document {
	Key => {sunGraph, (sunGraph, ZZ)},
	
	Headline => "construct a sun graph",
	
	Usage => "sunGraph n",
	
	Inputs => {
	    	"n" => ZZ => {"greater than 2"},
		},
	
	Outputs => {
		Graph => {"the n-sun graph"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"A n-sun graph, also sometimes called an n-trampoline, is the graph on 2n
	    vertices v_1,...,v_n, w_1,...,w_n in which the v_i form a complete graph and
	    w_i is adjacent to only v_i and v_{i+1} for i < n and w_n is adjacent to only
	    v_n and v_1."},   
	
	EXAMPLE {
		"G = sunGraph 4"
		},
	    
	SeeAlso => {isStronglyChordal}
	    }	
 
